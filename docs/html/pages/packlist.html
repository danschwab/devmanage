<div id="tabSystem">
</div>

<script type="module">
    import { TabManager, GoogleSheetsService, GoogleSheetsAuth, TableManager, ModalManager, SPREADSHEET_IDS } from './js/index.js';

    // Modular checkSaveAllState function
    function checkSaveAllState(mainTable, saveAllBtn) {
        // Check for any dirty cell in main table or any sub-table
        const dirty = mainTable.querySelector('.table-edit-textarea.dirty');
        if (dirty) {
            console.log('[checkSaveAllState] Found dirty cell:', dirty);
        } else {
            console.log('[checkSaveAllState] No dirty cells found');
        }
        // Check for any row moved (originalIndex != current index), new, or deleted rows
        let moved = false;
        // Check main table
        const checkMoved = (tbody, tableName = 'mainTable') => {
            if (!tbody) {
                console.log(`[checkSaveAllState] No tbody found for ${tableName}`);
                return false;
            }
            // Also check tfoot for deleted rows
            const table = tbody.closest('table');
            let tfootRows = [];
            if (table) {
                const tfoot = table.querySelector('tfoot');
                if (tfoot) {
                    tfootRows = Array.from(tfoot.querySelectorAll('tr.draggable'));
                }
            }
            // Mark all rows with their current index if not already set
            Array.from(tbody.rows).forEach((row, idx) => {
                if (row.dataset.originalIndex === undefined) {
                    // If not set, set it to current index
                    row.dataset.originalIndex = idx.toString();
                }
            });
            // Check for any row that has moved, is new, or has been removed
            let movedOrNew = false;
            Array.from(tbody.rows).forEach((row, idx) => {
                // Row is new if it has no originalIndex or originalIndex is empty
                if (row.dataset.originalIndex === undefined || row.dataset.originalIndex === '') {
                    movedOrNew = true;
                }
                // Row is moved if originalIndex does not match current index
                else if (parseInt(row.dataset.originalIndex) !== idx) {
                    movedOrNew = true;
                }
                // Row is new if originalIndex is -1 (see newRowFunction below)
                else if (row.dataset.originalIndex === '-1') {
                    movedOrNew = true;
                }
            });
            // If number of rows has changed, that's a removal or addition
            if (tbody.rows.length !== Object.keys(tbody.rows).length) {
                movedOrNew = true;
            }
            // If any row is in tfoot, that's a deletion (flag as movement)
            if (tfootRows.length > 0) {
                movedOrNew = true;
            }
            // NEW: If any row that was originally in tbody is now in tfoot, flag as movement
            // (i.e., if any tfoot row has a data-original-index that matches any tbody row's originalIndex)
            const tbodyOriginalIndexes = Array.from(tbody.rows).map(row => row.dataset.originalIndex);
            for (const tfootRow of tfootRows) {
                // If this row's originalIndex is not -1 (i.e., not a new row), and it was ever in tbody, flag as movement
                if (tfootRow.dataset.originalIndex !== undefined && tfootRow.dataset.originalIndex !== '-1') {
                    movedOrNew = true;
                }
            }
            if (movedOrNew) {
                console.log(`[checkSaveAllState] Row moved/new/removed in ${tableName}`);
                return true;
            }
            return false;
        };
        const mainTbody = mainTable.querySelector('tbody');
        if (checkMoved(mainTbody, 'mainTable')) moved = true;
        // Check all sub-tables
        mainTable.querySelectorAll('table').forEach((subTable, i) => {
            if (subTable === mainTable) return;
            const subTbody = subTable.querySelector('tbody');
            if (checkMoved(subTbody, `subTable[${i}]`)) moved = true;
        });
        console.log('[checkSaveAllState] dirty:', !!dirty, 'moved:', moved, 'saveAllBtn.disabled:', !(dirty || moved));
        
        // After all movement/dirty checks, update index column for main pack-list table
        // Find the main pack-list table (class drag-id-pack-list)
        const mainPackListTable = mainTable.closest('div').querySelector('table.drag-id-pack-list');
        if (mainPackListTable) {
            const tbody = mainPackListTable.querySelector('tbody');
            if (tbody) {
                Array.from(tbody.rows).forEach((row, idx) => {
                    // The index column is the second cell (after drag handle)
                    const indexTd = row.cells[1];
                    if (indexTd) {
                        indexTd.textContent = (idx + 1).toString();
                    }
                });
            }
        }

        if (saveAllBtn) {
            saveAllBtn.disabled = !(dirty || moved);
        }
        return { dirty, moved };
    }

    function buildPackListTable(content, tabName = null) {
        const mainTableData = content.crates.map((crate, crateIdx) => {
            const itemData = document.createElement('div');
            itemData.classList.add('table-wrapper');
            let itemTable = null;
            let saveBtn = null;
            // Always create an item table, even if crate.items is empty
            itemTable = TableManager.buildTable(
                crate.items,
                content.headers.items,
                ['Pack', 'Check'],
                ['Description','Packing/shop notes'],
                'pack-list-items',
                ['.tab-button'],
                newRowFunction
            );
            itemData.appendChild(itemTable);
            return [...crate.info, itemData];
        });

        const headers = [...content.headers.main, 'Items'];
        const mainTable = TableManager.buildTable(
            mainTableData,
            headers,
            [],
            ['Type','L','W','H','Weight'],
            'pack-list',
            ['.tab-button'],
            newRowFunction
        );

        // Remove gid logic (no longer used)
        // if (tabGid) {
        //     mainTable.dataset.gid = tabGid;
        // }

        // Add whole-table save button if tabName is provided
        if (tabName) {
            // Add Print Pack List button before the table
            const printBtn = document.createElement('button');
            printBtn.textContent = 'Print';
            printBtn.className = 'print-packlist-button';
            printBtn.style.margin = '12px 8px 12px 0';
            printBtn.onclick = async () => {
                // const gid = mainTable.dataset.gid || 0; // gid no longer used
                // Before opening the modal, check if there are unsaved changes and save if needed
                const { dirty, moved } = checkSaveAllState(mainTable, null);
                if (dirty || moved) {
                    printBtn.disabled = true;
                    try {
                        await savePackListTable(
                            mainTable,
                            SPREADSHEET_IDS.PACK_LISTS,
                            tabName
                        );
                        ModalManager.notify('Pack list saved before printing.', { timeout: 1500 });
                    } catch (err) {
                        ModalManager.alert('Could not save before printing: ' + (err && err.message ? err.message : err));
                        printBtn.disabled = false;
                        return;
                    }
                    printBtn.disabled = false;
                }
                // Hide all other tabs and show only the requested tab, then open the sheet
                await GoogleSheetsService.showOnlyTab(SPREADSHEET_IDS.PACK_LISTS, tabName);
                const modal = ModalManager.createModal(`
                    <p>Opening pack list for printing. Press Ctrl+P or navigate to File &gt; Print to print.</p>
                    <button class="open-print-btn">Open For Printing</button>
                `, { title: 'Open For Printing' });
                const btn = modal.querySelector('.open-print-btn');
                btn.addEventListener('click', () => {
                    window.open(
                        `https://docs.google.com/spreadsheets/d/${SPREADSHEET_IDS.PACK_LISTS}`,
                        '_blank'
                    );
                    modal.hide();
                });
            };

            const saveAllBtn = document.createElement('button');
            saveAllBtn.textContent = 'Save';
            saveAllBtn.className = 'save-button';
            saveAllBtn.style.margin = '12px 0';
            saveAllBtn.disabled = true;

            // Use modular checkSaveAllState
            const checkAllState = () => checkSaveAllState(mainTable, saveAllBtn);

            // Observe dirty state and row moves
            const observer = new MutationObserver(checkAllState);
            observer.observe(mainTable, {
                subtree: true,
                attributes: true,
                attributeFilter: ['data-dirty', 'data-original-index', 'class']
            });
            // Also observe for row additions/removals (childList)
            observer.observe(mainTable.querySelector('tbody'), {
                childList: true,
                subtree: false // only direct children (rows)
            });

            // Also check on input events (for contenteditable changes)
            mainTable.addEventListener('input', checkAllState);

            // Also check after drag/drop (row move)
            mainTable.addEventListener('mouseup', () => setTimeout(checkAllState, 10));

            saveAllBtn.onclick = async () => {
                saveAllBtn.disabled = true;
                try {
                    await savePackListTable(
                        mainTable,
                        SPREADSHEET_IDS.PACK_LISTS,
                        tabName
                    );
                    // Clear cache for this pack list after saving
                    GoogleSheetsService.clearCache(SPREADSHEET_IDS.PACK_LISTS, tabName);
                    ModalManager.notify('Pack list saved successfully');
                    // Rerun inventory check after save
                    checkPackListQuantities(tabName);
                } catch (err) {
                    console.error('Error saving entire pack list:', err && err.stack ? err.stack : err);
                    ModalManager.alert('Error saving entire pack list: ' + (err && err.message ? err.message : err));
                } finally {
                    checkAllState();
                }
            };
            // Wrap table and button in a container
            const wrapper = document.createElement('div');
            wrapper.appendChild(printBtn);
            wrapper.appendChild(saveAllBtn);
            wrapper.appendChild(mainTable);
            return wrapper;
        }
        return mainTable;
    }

    async function checkPackListQuantities(tabName) {
        try {
            console.log('[checkPackListQuantities] Checking quantities for tab:', tabName);

            // Get all open tabs (by tab button data-tab attribute)
            const openTabButtons = document.getElementById('tabSystem').querySelectorAll('.tab-button[data-tab]');
            const openTabNames = Array.from(openTabButtons)
                .map(btn => btn.getAttribute('data-tab'))
                .filter(Boolean);

            // Helper to denormalize tab names (replace underscores with spaces)
            function denormalizeTabName(tab) {
                return tab.replace(/_/g, ' ');
            }

            // Get overlapping shows for the current tabName only once
            const overlappingShowTabs = await GoogleSheetsService.getOverlappingShows({ identifier: tabName });
            console.log('[checkPackListQuantities] Overlapping shows:', overlappingShowTabs);

            // Build the update list: tabName first, then intersection of openTabNames and overlappingShowTabs (excluding tabName)
            const updateTabs = [
                tabName.replace(/[^a-zA-Z0-9-_]/g, '_'), // Normalize tabName to match sheet tab names
                ...openTabNames
                    .filter(t => t !== tabName && overlappingShowTabs && overlappingShowTabs.includes(denormalizeTabName(t)))
            ];
            console.log('[checkPackListQuantities] Tabs to check:', updateTabs);

            let primaryChecked = false;

            // Now, run the inventory check for each tab in the update list
            for (const openTab of updateTabs) {
                const isPrimary = openTab === tabName;
                console.log(`[checkPackListQuantities] Checking tab: ${openTab} (primary: ${isPrimary})`);

                // Remove only inventory reports and cell cards for this tab
                // Remove inventory report(s) for this tab
                // Find the tab content container for this tab
                const tabContent = document.getElementById(openTab);
                if (tabContent) {
                    console.log(`[checkPackListQuantities] Clearing previous inventory reports and cell cards for tab: ${openTab}`);
                    // Remove all inventory reports for this tab
                    tabContent.querySelectorAll('.inventory-report-container').forEach(el => {
                        console.log(`[checkPackListQuantities] Removing inventory report container for tab: ${openTab}`);
                        el.remove();
                    });
                    // Remove all cell cards for this tab's items
                    tabContent.querySelectorAll('.drag-id-pack-list-items td .table-cell-card').forEach(card => {
                        console.log(`[checkPackListQuantities] Removing table cell card in tab: ${openTab}`);
                        card.remove();
                    });
                }

                // Silently skip if there are no crates to check
                let quantityData;
                try {
                    quantityData = await GoogleSheetsService.checkItemQuantities(denormalizeTabName(openTab));
                } catch (err) {
                    console.warn(`[checkPackListQuantities] Error checking quantities for ${openTab}:`, err);
                    if (isPrimary) {
                        console.warn('[checkPackListQuantities] Aborting: error in primary packlist.');
                        return;
                    }
                    continue;
                }
                if (!quantityData) {
                    console.log(`[checkPackListQuantities] No items found in pack list for ${openTab}.`);
                    if (isPrimary) {
                        console.warn('[checkPackListQuantities] Aborting: no items in primary packlist.');
                        return;
                    }
                    continue;
                }
                if (isPrimary) primaryChecked = true;

                const headers = ['Item', 'Inventory', 'Requested', 'Remaining', 'Overlapping Shows', 'Status'];
                const rows = Object.entries(quantityData).map(([itemId, info]) => {
                    const status = info.remaining > 0 ? 'OK' : 'Warning';
                    const statusCell = document.createElement('span');
                    statusCell.textContent = status;
                    statusCell.className = status === 'OK' ? 'table-cell-card green' : 'table-cell-card red';
                    return [
                        itemId,
                        info.inventory,
                        info.requested,
                        info.remaining,
                        buildTabsListElement(info.overlapping),
                        statusCell
                    ];
                });

                if (!rows.length) {
                    console.log(`[checkPackListQuantities] No rows to display for ${openTab}, skipping table build.`);
                    continue;
                }

                const table = TableManager.buildTable(rows, headers);
                table.classList.add('quantity-check-table');

                // Create a div to hold the table with a logical heading
                const inventoryReportContainer = document.createElement('div');
                const heading = document.createElement('h2');
                heading.textContent = `Inventory report for: ${denormalizeTabName(openTab)}`;
                inventoryReportContainer.classList.add('inventory-report-container');
                inventoryReportContainer.appendChild(heading);
                inventoryReportContainer.appendChild(table);
                if (tabContent) {
                    tabContent.appendChild(inventoryReportContainer);
                }

                // Highlight error items in pack list table for this tab
                rows.forEach(row => {
                    const itemId = row[0];
                    const remaining = row[3];
                    if (remaining < 0 || remaining === 0) {
                        const color = remaining < 0 ? 'red' : 'yellow';
                        // Find all matching pack-list-items tables for this tab
                        tabContent.querySelectorAll('.drag-id-pack-list-items td').forEach(packListItem => {
                            const itemRegex = /(?:\(([0-9]+)\))?\s*([A-Z]+-[0-9]+[a-zA-Z]?)/;
                            const match = packListItem.textContent.match(itemRegex);
                            if (match && match[2] === itemId) {
                                TableManager.tableCellCard(
                                    packListItem,
                                    remaining < 0
                                        ? `<strong>Warning: </strong>insufficient inventory (${remaining})`
                                        : '<strong>Warning: </strong>no inventory margin',
                                    color,
                                    '.inventory-report-container'
                                );
                            }
                        });
                    }
                });
            }
            if (!primaryChecked) {
                console.warn('[checkPackListQuantities] Primary packlist was not checked or had no items. Aborting.');
                return;
            }
        } catch (err) {
            console.error('Error building quantity check table:', err && err.stack ? err.stack : err);
            ModalManager.alert('Failed to check item quantities.');
        }
    }

    // Extracted function to build the tabs-list DOM element from a list of sheetTabs
    function buildTabsListElement(sheetTabs) {
        if (!sheetTabs || sheetTabs.length === 0) {
            const noTabsMessage = document.createElement('p');
            noTabsMessage.textContent = '-';
            return noTabsMessage;
        }
        
        const tabsList = document.createElement('div');
        tabsList.className = 'tabs-list';
        for (const tabName of sheetTabs) {
            if (tabName === 'TEMPLATE') continue;
            const tabButton = document.createElement('button');
            tabButton.classList.add('tab-button');
            tabButton.textContent = tabName;
            tabsList.appendChild(tabButton);
            tabButton.addEventListener('click', async () => {
                // Remove modal if present
                const modal = document.querySelector('.modal');
                if (modal) modal.hide();
                const loadingModal = ModalManager.showLoadingIndicator('Setting up pack list...');
                try {
                    // Fetch gid for this tab
                    let isNewTab = false;
                    // Check if the tab already exists by getting all tab names
                    const sheetTabs = await GoogleSheetsService.getSheetTabs(SPREADSHEET_IDS.PACK_LISTS);
                    if (!sheetTabs.includes(tabName)) {
                        // Tab does not exist, copy TEMPLATE sheet
                        await GoogleSheetsService.copySheetTab(SPREADSHEET_IDS.PACK_LISTS, "TEMPLATE", tabName);
                        isNewTab = true;
                    }
                    // If we just created the tab, set the show identifier in cell E1
                    if (isNewTab) {
                        await GoogleSheetsService.setSheetData(
                            SPREADSHEET_IDS.PACK_LISTS,
                            tabName,
                            [
                                { row: 0, col: 4, value: tabName }
                            ]
                        );
                    }
                    let content;
                    try {
                        content = await GoogleSheetsService.getPackListContent(tabName);
                    } catch (contentErr) {
                        // If content fetch fails (e.g., new tab), use empty structure
                        content = {
                            crates: [],
                            headers: {
                                main: ['Type', 'L', 'W', 'H', 'Weight', 'Notes'],
                                items: ['Description', 'Packing/shop notes']
                            }
                        };
                    }
                    const tabContainer = document.createElement('div');
                    // Pass tabName to buildPackListTable so save buttons and print button are added
                    const packListTable = buildPackListTable(content, tabName);
                    tabContainer.appendChild(packListTable);

                    // Asynchronously check item quantities
                    checkPackListQuantities(tabName);

                    TabManager.addNewTab('tabSystem', tabName, tabContainer, true, true);
                    loadingModal.hide();
                    } catch (error) {
                        loadingModal.hide();
                        console.error('Error loading sheet content:', error);
                        ModalManager.alert('Failed to load content');
                    }
            });
        }
        return tabsList;
    }

    // Standalone function for TabManager tab handler
    async function addNewPackListTab() {
        await GoogleSheetsAuth.checkAuth();

        const modal = ModalManager.createModal(`
            <p class="loading-message">Getting shows from production schedule...</p>
        `);

        try {
            const sheetTabs = await GoogleSheetsService.getSheetTabs(SPREADSHEET_IDS.PACK_LISTS);
            const tabsListElement = buildTabsListElement(sheetTabs);
            const modalBody = modal.querySelector('.modal-body');
            modalBody.innerHTML = '<div id="open-pack-list-tab-system"><p style="margin-bottom: 20px;">Select a pack list:</p></div>';
            await TabManager.buildTabSystem('open-pack-list-tab-system');
            // Ensure the tab system is present before adding tabs
            const tabSystemDiv = document.getElementById('open-pack-list-tab-system');
            TabManager.addNewTab(tabSystemDiv, 'Open Existing', tabsListElement, false, true);

            // Immediately create the 'Create New' tab with loading message and get its content element
            const loadingDiv = document.createElement('div');
            loadingDiv.innerHTML = `<p class="loading-message">Getting shows from production schedule...</p>`;
            const createNewTab = await TabManager.addNewTab(tabSystemDiv, 'Create New', loadingDiv, false, true, false);
            const createNewTabContent = createNewTab.tabContent;

            // Asynchronously get overlapping shows and update the 'Create New' tab
            GoogleSheetsService.getOverlappingShows({
                startDate: '2025-01-01',
                endDate: '2025-03-01'
            }).then(overlappingShows => {
                const existingTabs = new Set(sheetTabs);
                const filteredOverlappingShows = overlappingShows.filter(show => !existingTabs.has(show));
                const newTabsListElement = buildTabsListElement(filteredOverlappingShows);
                // Replace the content using the returned element
                if (createNewTabContent) {
                    createNewTabContent.innerHTML = '';
                    createNewTabContent.appendChild(newTabsListElement);
                }
            }).catch(error => {
                console.error('Error loading overlapping shows:', error);
                if (createNewTabContent) {
                    createNewTabContent.innerHTML = '<p class="error">Failed to load shows</p>';
                }
            });
        } catch (error) {
            console.error('Error loading sheet tabs:', error);
            modal.querySelector('.modal-body').innerHTML = '<p class="error">Failed to load tabs</p>';
        }
    }

    /**
     * Save the entire pack list table (all crates and their items) to Google Sheets.
     * Only writes data rows (no header row).
     * @param {HTMLTableElement} mainTable - The main pack list table element.
     * @param {string} sheetId - The Google Sheets ID.
     * @param {string} tabName - The sheet/tab name.
     * @param {function} setSheetData - Function to call for saving (should match GoogleSheetsService.setSheetData).
     * @returns {Promise<void>}
     */
    async function savePackListTable(mainTable, sheetId, tabName) {
        const loadingModal = ModalManager.showLoadingIndicator('Saving pack list...');
        try {
            console.log('[savePackListTable] Starting save for tab:', tabName);

            // 1. Gather all crate rows (main table body)
            const tbody = mainTable.querySelector('tbody');
            const crateRows = Array.from(tbody.children).filter(el => el.tagName === 'TR');
            const result = [];

            console.log('[savePackListTable] Found crate rows:', crateRows.length);

            for (const [crateIdx, crateRow] of crateRows.entries()) {
                console.log(`[savePackListTable] Processing crate row ${crateIdx}`);
                const crateCells = Array.from(crateRow.children).filter(el => el.tagName === 'TD');
                console.log(`[savePackListTable] Crate row ${crateIdx} has ${crateCells.length} cells`);
                // Only process rows with at least 7 cells (drag + 6 crate info + items)
                if (crateCells.length < 7) {
                    console.warn(`[savePackListTable] Skipping crate row ${crateIdx} due to insufficient cells (${crateCells.length})`);
                    continue;
                }

                // 2. Append crate data row (cells 1-6, skip drag handle)
                const crateData = crateCells.slice(1, 7).map((td, i) => {
                    const editable = td.querySelector('.table-edit-textarea');
                    const value = editable ? editable.textContent.trim() : td.textContent.trim();
                    console.log(`[savePackListTable] Crate row ${crateIdx}, cell ${i + 1}: "${value}"`);
                    return value;
                });
                console.log(`[savePackListTable] Pushing crate data for row ${crateIdx}:`, crateData);
                result.push(crateData);

                // 3. For each item in the crate's item table, append a row with 8 empty, then 2 item values
                const itemsCell = crateCells[7];
                if (!itemsCell) {
                    console.warn(`[savePackListTable] No items cell found for crate row ${crateIdx}`);
                    continue;
                }
                const itemsTable = itemsCell.querySelector('table');
                if (itemsTable) {
                    const itemsTbody = itemsTable.querySelector('tbody');
                    if (itemsTbody) {
                        const itemRows = Array.from(itemsTbody.querySelectorAll('tr'));
                        console.log(`[savePackListTable] Found ${itemRows.length} item rows for crate ${crateIdx}`);
                        for (const [itemIdx, itemTr] of itemRows.entries()) {
                            const itemTds = Array.from(itemTr.querySelectorAll('td')).slice(1); // skip drag handle
                            if (itemTds.length >= 2) {
                                const itemData = itemTds.map((td, j) => {
                                    const editable = td.querySelector('.table-edit-textarea');
                                    const value = editable ? editable.textContent.trim() : td.textContent.trim();
                                    console.log(`[savePackListTable] Crate ${crateIdx}, item row ${itemIdx}, cell ${j + 1}: "${value}"`);
                                    return value;
                                });
                                if (itemData.some(cell => cell.length > 0)) {
                                    console.log(`[savePackListTable] Pushing item data for crate ${crateIdx}, item row ${itemIdx}:`, itemData.slice(0, 2));
                                    result.push([
                                        '', '', '', '', '', '', '', '', // 8 empty columns
                                        ...itemData.slice(0, 2)
                                    ]);
                                } else {
                                    console.log(`[savePackListTable] Skipping empty item row ${itemIdx} in crate ${crateIdx}`);
                                }
                            } else {
                                console.warn(`[savePackListTable] Item row ${itemIdx} in crate ${crateIdx} has insufficient cells (${itemTds.length})`);
                            }
                        }
                    } else {
                        console.warn(`[savePackListTable] No tbody found in items table for crate ${crateIdx}`);
                    }
                } else {
                    console.warn(`[savePackListTable] No items table found in items cell for crate ${crateIdx}`);
                }

                if (crateIdx < crateRows.length - 1) {
                    result.push(['']); // Add an empty row to separate crates
                }
            }

            console.log('[savePackListTable] Final result array:', result);

            // Delete all rows after row 4 (i.e., keep only rows 1-4)
            if (typeof gapi !== 'undefined' && gapi.client?.sheets?.spreadsheets?.get) {
                const sheetInfo = await GoogleSheetsService.withExponentialBackoff(() =>
                    gapi.client.sheets.spreadsheets.get({
                        spreadsheetId: sheetId,
                        ranges: [tabName],
                        includeGridData: false
                    })
                );
                const sheet = sheetInfo.result.sheets.find(s => s.properties.title === tabName);
                if (sheet) {
                    const sheetRowCount = sheet.properties.gridProperties.rowCount;
                    if (sheetRowCount > 4) {
                        console.log('[savePackListTable] Deleting rows after row 4:', sheetRowCount - 4);
                        await GoogleSheetsService.withExponentialBackoff(() =>
                            gapi.client.sheets.spreadsheets.batchUpdate({
                                spreadsheetId: sheetId,
                                resource: {
                                    requests: [
                                        {
                                            deleteDimension: {
                                                range: {
                                                    sheetId: sheet.properties.sheetId,
                                                    dimension: 'ROWS',
                                                    startIndex: 4, // 0-based, so row 5
                                                    endIndex: sheetRowCount
                                                }
                                            }
                                        }
                                    ]
                                }
                            })
                        );
                    }
                }
            }

            // Insert the new data starting at row 4, column A
            console.log('[savePackListTable] Writing data to sheet:', result.length, 'rows');
            await GoogleSheetsService.setSheetData(sheetId, tabName, {
                type: 'full-table',
                values: Array.isArray(result) ? result : [],
                startRow: 3 // 1-based for Sheets API, row 4
            });

            // Remove any rows in tfoot after successful save
            mainTable.querySelectorAll('tfoot').forEach(tfoot => {
                Array.from(tfoot.querySelectorAll('tr.draggable')).forEach(tr => tr.remove());
            });

            TableManager.clearDirtyState(mainTable);
            console.log('[savePackListTable] Save complete');
        } finally {
            loadingModal.hide();
        }
    }

    function newRowFunction(event) {
        const table = event.target.closest('table');
        if (!table) return;
        const dragIdClass = Array.from(table.classList).find(cls => cls.startsWith('drag-id-'));
        const tbody = table.querySelector('tbody');
        if (!tbody) return;

        // Find the nearest main table to get content.headers.items
        let headersItems = null;
        let parent = table;
        while (parent) {
            if (parent.classList && parent.classList.contains('drag-id-pack-list')) {
                // Try to find the headers from the mainTableData context
                if (window._packListHeadersItems) {
                    headersItems = window._packListHeadersItems;
                }
                break;
            }
            parent = parent.parentElement;
        }
        // Fallback: try to get from global if available
        if (!headersItems && window._packListHeadersItems) {
            headersItems = window._packListHeadersItems;
        }
        // If still not found, try to get from the first .drag-id-pack-list-items table
        if (!headersItems) {
            const firstItemsTable = document.querySelector('.drag-id-pack-list-items');
            if (firstItemsTable) {
            const ths = firstItemsTable.querySelectorAll('thead th');
            headersItems = Array.from(ths)
                .filter(th => !th.classList.contains('spacer-cell'))
                .map(th => th.textContent.trim());
            }
        }
        // If still not found, fallback to ['Description', 'Packing/shop notes']
        if (!headersItems) {
            headersItems = ['Description', 'Packing/shop notes'];
        }

        console.log(`[newRowFunction] Adding new row to table with class: ${dragIdClass}`);

        if (dragIdClass === 'drag-id-pack-list-items') {
            // Add a new draggable row with 2 editable cells
            const rowIndex = tbody.rows.length;
            const tr = document.createElement('tr');
            tr.classList.add('draggable');
            // Mark as new row for movement detection
            tr.dataset.originalIndex = '-1';
            // Drag handle
            const dragTd = document.createElement('td');
            dragTd.className = 'row-drag-handle';
            tr.appendChild(dragTd);
            // 2 editable cells
            for (let i = 0; i < 2; i++) {
                const td = document.createElement('td');
                const editableDiv = document.createElement('div');
                editableDiv.setAttribute('role', 'textbox');
                editableDiv.setAttribute('contenteditable', 'true');
                // Set initial value to a unique marker so it is always dirty until edited
                editableDiv.dataset.originalValue = '';
                editableDiv.dataset.rowIndex = -1;//rowIndex; initialize as -1 to indicate new row
                editableDiv.dataset.colIndex = i + 2; // skip drag handle and possible hidden columns
                editableDiv.dataset.dirty = 'true';
                editableDiv.classList.add('table-edit-textarea', 'dirty');
                editableDiv.textContent = '';
                editableDiv.addEventListener('input', (e) => {
                    const target = e.target;
                    const isDirty = (target.textContent !== target.dataset.originalValue);
                    target.dataset.dirty = isDirty.toString();
                    if (isDirty) {
                        target.classList.add('dirty');
                    } else {
                        target.classList.remove('dirty');
                    }
                    console.log(`[newRowFunction] Cell edited in pack-list-items row ${rowIndex}, col ${i + 2}, dirty: ${isDirty}`);
                });
                td.appendChild(editableDiv);
                tr.appendChild(td);
            }
            tbody.appendChild(tr);
            console.log(`[newRowFunction] Added new row to pack-list-items table at index ${rowIndex}`);
        } else if (dragIdClass === 'drag-id-pack-list') {
            // Add a new draggable row with 7 columns: first 6 editable, last is a new pack-list-items table
            const rowIndex = tbody.rows.length;
            const tr = document.createElement('tr');
            tr.classList.add('draggable');
            // Mark as new row for movement detection
            tr.dataset.originalIndex = '-1';
            // Drag handle
            const dragTd = document.createElement('td');
            dragTd.className = 'row-drag-handle';
            tr.appendChild(dragTd);
            // First cell is uneditable (for row index)
            const indexTd = document.createElement('td');
            tr.appendChild(indexTd);
            // 5 editable cells
            for (let i = 1; i < 6; i++) {
                const td = document.createElement('td');
                const editableDiv = document.createElement('div');
                editableDiv.setAttribute('role', 'textbox');
                editableDiv.setAttribute('contenteditable', 'true');
                // Set initial value to a unique marker so it is always dirty until edited
                editableDiv.dataset.originalValue = '';
                editableDiv.dataset.rowIndex = rowIndex;
                editableDiv.dataset.colIndex = i + 1; // skip drag handle
                editableDiv.dataset.dirty = 'true';
                editableDiv.classList.add('table-edit-textarea', 'dirty');
                editableDiv.textContent = '';
                editableDiv.addEventListener('input', (e) => {
                    const target = e.target;
                    const isDirty = (target.textContent !== target.dataset.originalValue);
                    target.dataset.dirty = isDirty.toString();
                    if (isDirty) {
                        target.classList.add('dirty');
                    } else {
                        target.classList.remove('dirty');
                    }
                    console.log(`[newRowFunction] Cell edited in pack-list row ${rowIndex}, col ${i + 1}, dirty: ${isDirty}`);
                });
                td.appendChild(editableDiv);
                tr.appendChild(td);
            }
            // 7th cell: new pack-list-items table
            const itemsTd = document.createElement('td');
            itemsTd.className = 'table-wrapper';
            // Create an empty pack-list-items table with newRowFunction
            const itemsTable = TableManager.buildTable(
                [],
                headersItems,
                ['Pack', 'Check'],
                ['Description', 'Packing/shop notes'],
                'pack-list-items',
                ['.tab-button'],
                newRowFunction
            );
            itemsTd.appendChild(itemsTable);
            tr.appendChild(itemsTd);
            tbody.appendChild(tr);
            console.log(`[newRowFunction] Added new row to pack-list table at index ${rowIndex}`);
        }
    }
        

    // Initialize the TabManager with tab handler
    TabManager.buildTabSystem('tabSystem', addNewPackListTab);


</script>